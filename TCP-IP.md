# TCP / IP
一句话总结：
* 以太网层发送ARP广播，查询某个IP对应的MAC地址，由相关主机负责回复
* 以太网层发送RARP广播，根据自己的MAC地址查IP地址（DHCP前的老协议，由其他主机负责配IP地址）
* 网路不可达、主机不可达、端口不可达时，路由器或主机回复一条ICMP通知发起方
* ping：ICMP回显请求与回复
* traceroute：发送`TTL=(1,2,3,4,...)`的UDP空包（端口随便取），利用超时或端口不可达的回复获得经过的主机IP
* 路由器发现：路由器定期发ICMP通告自己的地址，主机引导时发ICMP请求网络内的路由器信息
* 路由器定向：如果网络内有多个路由器负责不同地址的转发，路由器A收到不属于自己负责的IP包后，转交给路由器B去处理，并发ICMP告知主机重定向相关地址路由到B
* DNS查询：DNS服务器有层次结构，每个DNS服务器可能只负责某个范围的域名解析，超过范围时会告知客户端使用上一级的DNS服务器重试

## TCP
* 三次握手，避免第一次SYN是过期消息，服务器提前进入ESTABLISHED状态
* 四次挥手，因为TCP全双工，需要分别关闭两个方向的连接
    * 主动关闭方：
        * 发送FIN，进入FIN_WAIT_1状态
        * 收到ACK，进入FIN_WAIT_2状态
        * 继续收对方发来的数据
        * 收到FIN，回ACK，进入TIME_WAIT状态，等待2MSL后再完全关闭（如果ACK丢包，对方回重发FIN，需要重新响应重新等2MSL）
    * 被动关闭方：
        * 收到FIN，进入CLOSE_WAIT状态
        * 继续发数据
        * 数据发完后发送FIN，进入LAST_ACK状态
        * 收到ACK后完全关闭
* 可以同时打开TCP连接（双方并发向对方发SYN）
* 可以同时关闭TCP连接（双方并发向对方发FIN）
* TCP_REUSEADDR：重用TIME_WAIT中的端口
* TCP_NODELAY：禁用Nagle算法
* MSS：最大报文段长度，建立连接握手时通过选项发送
* 通告窗口：告知对方自己的接收缓冲区还可收多少字节的数据
* 拥塞窗口：发送方自行判断网络状况，控制在没有ACK前可发送多少字节数
* 慢启动：数据成功ACK后指数扩大拥塞窗口，超过某个阈值后每次增加MSS的字节数
* 糊涂窗口综合征，即每个包只携带少量数据，发生条件如下：
    * 发送方每次只产生少量数据就发送了（解决方法：把数据包攒大再发送、Nagle算法）
    * 接收方缓冲区满了，应用层每次只取少量数据，传输层立即通告仅有N字节的小窗口（解决方法：把窗口攒大再通告）
* 坚持定时器：由接收方负责通知发送方窗口为0时开启；由于窗口通告是走ACK发送的，接收方通知发送方自己恢复可接收数据的状态时可能丢包，需要发送方定时查询对方的状态——发送方只发送1字节的数据，用于窗口探查（如果没有数据要发，超时时没法马上去查询？等到有数据要发时再查询？）
* 保活定时器：发送个空包给对方，序列号为对方上次回的ACK号减一
    * 对方如果在同一个子网内？先发ARP查对方MAC地址再发空包，可通过超时检测到对方已崩溃
    * 对方在其他网络？可通过ICMP信息检测对方是否可达
    * 对方崩溃后重启？发空包后会收到RST消息