# 通过网络收发数据的流程
以Linux下发送文件为例，通过调用`read`、`write`方法的流程如下：
* 用户态：调用`read()`
* 内核态：
    * DMA操作将数据从磁盘拷贝到内核缓存
    * 将数据从内核缓存拷贝到用户缓存
* 用户态：调用`write()`
* 内核态：
    * 将数据从用户缓存拷贝到内核缓存
    * DMA操作将数据从内核缓存拷贝到网卡
总共发生了3次CPU拷贝。

如果使用`sendfile`方法：
* 用户态：调用`sendfile()`
* 内核态：
    * DMA操作将数据从磁盘拷贝到内核缓存
    * 将数据所在的内核缓存的文件描述符添加到关联网卡的内核缓存中
    * DMA操作将数据从内核缓存拷贝到网卡
没有发生CPU拷贝，即所谓的“零拷贝”。Java提供了`FileChannel`实现该机制。

# 使用HeapByteBuffer会多一次拷贝
在Java中，对于非文件的读写，如果使用`HeapByteBuffer`收发数据，收发数据前都要分配一个临时的`DirectByteBuffer`：
* 通过系统调用从内核缓存拷贝接收到的数据，之后再将数据拷贝到`HeapByteBuffer`中
* 从`HeapByteBuffer`拷贝数据，之后再通过系统调用将数据拷贝到内核缓存中
即需要多一次CPU拷贝的过程，原因是因为GC的缘故，堆中的数据位置可能会变动，但无法被内核感知，因此需要分配一块原生内存。

如果直接使用`DirectByteBuffer`，可以省去这次拷贝。原生内存受OS管理，申请开销比新建对象更大，一般都是分配一大块内存再由逻辑实现一套内存管理机制。