# B树


## 特征
* 树高为`O(lgn)`
* 每个节点可以存n个key（有序），每个key作为一个分割点分割n+1个子节点
* 所有叶节点高度一致
* 最小度t：每个非根节点至少有t-1个key（即非根中间节点至少有t个子节点），最多2t-1个key（即非根中间节点最多有2t个子节点）。
* 树高 <= `log(t, (n+1/2))`


## B+树的改动：
* 每个key对应一个指针指向下层节点（而非一个key分出两个子节点指针）
* 同层节点之间构成链表
* 中间节点只存key和子节点指针，叶子节点包含所有的key，且包含数据指针

B+树相比B树，中间节点更紧凑，每层能存储更多的分支信息；同层节点间的指针方便扫读指定key范围的所有数据。


## 操作B树
搜索：如果使用线性搜索，时间复杂度为`O(tlog(t, n))`。

插入key：
* 先找到相应的叶子节点准备插入；如果叶子节点已满，需要向上分裂
* 将已满节点分两半，取中位数移到上层节点中；如果上层节点也满了，继续向上分裂
* 如果根节点也满了，向上分裂得到一个新的根节点

移除key：
* 如果key在叶子节点中，直接删；如果最小度不满足：
    * 可能需要从父节点挪一个key下来补当前节点，从兄弟节点挪一个key上去补父节点
    * 可能要和某个兄弟节点合并，此时还需要从父节点抽一个key下来（相当于父节点也删了个key，需要处理中间节点删key的情况）
* 如果key在中间节点中：
    * 可能从某个子节点抽一个key上来补位
    * 可能需要合并两个子节点，当前节点的度减一
    * 如果当前节点度不够，继续递归向上、向兄弟节点借key（相当于把当前节点看成叶子节点再执行相关处理）
* 如果递归到树顶，最后可能要合并第二层节点再缩一层树高
