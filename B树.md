B树的定义：
* 每个节点中有n个key，按升序排列，分割形成n+1个指针指向下层节点
* B树的`最小度`t：每个非根节点至少有t-1个key，最多2t-1个key，即向下指针数量在`[t, 2t]`之间
* 所有叶子节点的高度一致（“平衡”）
* 树高 <= `log(t, (n+1/2))`

B+树的改动：
* 每个key对应一个指针指向下层节点
* 同层节点之间构成链表
* 中间节点只有key和子节点指针，叶子节点包含所有的key
* 仅叶子节点包含数据指针
B+树相比B树，中间节点更紧凑，每层能存储更多的分支信息；同层节点间的指针方便读取指定key范围的所有数据。

插入key的基本流程：
* 找到相应的叶子节点准备插入；如果叶子节点已满，需要向上分裂
* 将已满节点分两半，取中位数移到上层节点中；如果上层节点也满了，继续向上分裂
* 如果根节点也满了，向上分裂得到一个新的根节点

移除key的基本流程：
* 如果key在叶子节点中，且当前节点中key数量足够（当前至少t+1个key），直接移除该key
* 如果删除的key在中间节点中：
    * 如果任意子节点中key个数足够（当前至少t+1个key），把一个前驱或后继的key移上来替代当前key
    * 如果两个子节点key的个数都不足（当前都是t个key），当前节点中key个数足够（当前至少t+1个key），则移除指定的key、合并两个子节点、缩减一个指针
    * 否则需要向上层借key
* 向上层借key的情况：
    * 如果某个兄弟节点中兄弟数量足够（当前至少t+1个key），直接把上层的key移下来，兄弟节点中对应的key移上去
    * 如果上层的key数量足够（当前至少t+1个key），把上层的key移下来，再与兄弟节点合并、上层缩减一个指针
    * 否则上层需再向上上层借key；如果根节点也被借空，合并第一层子节点，树高减一层