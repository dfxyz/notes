# 图


## BFS
* 开一个队列记录待遍历的点
* 遍历时可以记录每个点到源点的距离，从而可以发现源点到任意点的最短距离


## DFS
* 递归逻辑
* 遍历时可以用一个counter记录每个点做DFS的开始时间与完成时间

### 拓扑排序
* DFS遍历图
* 每完成一个点的DFS，将其插入队列头部
* 最后得到有序的队列

### 强连通
有向图中的一个最大子集，对里面任意的点u、v，可以从u走到v，也可以从v走到u
* 对图G执行DFS，记录每个点u的遍历完成时间
* 计算图G的转置（即翻转图G里所有边的方向）
* 对图G的转置进行DFS（在主循环里按首次DFS每个点遍历完成时间倒序进行）
* 本次DFS得到的每棵树即强连通子集


## 最小生成树
### Kruskal算法
* 对图中所有边按权重升序排序，每次选取整个图中权重最小的边加入生成树
* 需要排除会形成环的情况，可利用并查集记录已连通的节点
* 时间复杂度O(|E|lg|V|)

### Prim算法
* 选取图中任意点作为生成树的初始点，每次选取与任意生成树节点相连的权重最小的边加入生成树
* 可以使用一个最小堆作为优先级队列维护尚未接入生成树的所有节点i
    * 排序规则为每个节点与生成树任意节点的最短距离
    * 初始状态下源点与生成树距离为0，其他节点与生成树距离为正无穷
    * 每次向生成树加入新节点之后更新相邻点的最短距离，再调整最小堆
* 时间复杂度O(|E|lg|V|)


## 单源最短路径
### Bellman-Ford算法
算法的时间复杂度是O(VE)，可以发现图中的负权重环路
* 假设图中有n个点，需要迭代n-1次
    * 遍历所有边，尝试缩减源点到每条边终点的距离
* 遍历所有边，检查是否有负权重环路（对于`u->v`，`源点到u的距离 + uv的权重 < 源点到v的距离?`）

### DAG的最短路径
* 初始化源点
* 计算DAG的拓扑排序
* 按照排序结果取点，进行迭代
    * 遍历取的点连接的其他点，尝试缩短距离

### Dijkstra算法
和Prim算法类似，只不过是指定了初始点
* 初始化源点的距离为0，其他点为正无穷
* 将所有点放入一个优先级队列
* 循环从优先级队列取点
    * 遍历该点直连的其他点，尝试缩减距离，再调整优先级队列

优先级队列可以用最小堆或者直接开一维数组；如果用数组，时间复杂度是O(|V|^2+|E|)，即O(|V|^2)，时间主要耗在取最优先的点上（时间复杂度O(|V|)），最多会调整|E|次顶点优先级；如果用最小堆，从最小堆取点和调整顶点优先级的时间复杂度是O(lg|V|)，总的时间复杂度是O((|V|+|E|)lg|V|)（所有点都互联时，则是O(|E|lg|V|)）

### AStar算法
与Dijkstra算法类似，但在计算源点到当前的距离以确定优先级时，使用的是两个数的和：
* 从源点走到当前点的距离（有累积的估算部分，并非实际距离）
* 从当前点到目标点的估算距离

估算距离的方法：
* 曼哈顿距离，`abs(p.x - q.x) + abs(p.y - q.y)`，适用于只能上下左右移动的场合
* 对角线距离，`max(abs(p.x - q.x), max(p.y - q.y))`，适用于可以八向移动的场合
* 欧几里得距离，`sqrt((p.x - q.x)**2 + (p.y - q.y)**2)`，适用于可以任意方向移动的场合
