# Undo日志
记录事务中被修改的数据的旧值，发生崩溃时可以恢复到事务提交前的状态。记录了`commit`后，事务的数据修改肯定已写回磁盘。

记录规则：
* 事务在主存中修改数据时，在日志中记录旧值
* 在修改写回磁盘前，先flush日志
* 在修改写回磁盘后，再记录`commit`并flush

恢复操作：
* 从后向前扫描整个undo日志
* 如果扫到某条数据修改记录，对应的事务没有结束记录（`commit`或`abort`），撤销修改；否则忽略
* 对所有被恢复的事务，追加一条`abort`记录，并写回磁盘

为防止扫描整个undo日志，可定时记录`checkpoint`：
* 开始时记录`startCheckpoint`（包含所有未完成的事务信息）并flush日志
* 检查点开始时的活动事务都提交或终止时，记录`endCheckpoint`并flush日志
恢复时，从后向前找到一对完整的`startCheckpoint`与`endCheckpoint`即可；`startCheckpoint`之前的日志可丢弃，检查并撤销`startCheckpoint`之后未提交事务的数据修改。


# Redo日志
记录事务中被修改的数据的新值，发生崩溃时可以恢复到事务提交后的状态。记录了`commit`之后，事务的数据不一定马上写回磁盘。

规则：
* 事务在内存中修改数据时，在日志中记录新值
* 在数据修改写回磁盘前先记录`commit`并flush日志
* 在之后某个时间点将数据修改写回磁盘

恢复操作：
* 从前向后扫描整个redo日志
* 如果扫到某条数据修改记录，且对应的事务的有提交记录，重做修改；否则忽略
* 对所有未完成的事务，增加一条`abort`记录，并写回磁盘

为防止扫描整个redo日志，可定时记录`checkpoint`：
* 开始时记录`startCheckpoint`（包含所有未提交的事务信息）并flush日志
* 确保已提交的事务的数据修改写回磁盘
* 记录`endCheckpoint`并flush日志
恢复时，从后向前找到一对完整的`startCheckpoint`与`endCheckpoint`即可；可根据`startCheckpoint`时记录的未提交的事务以及后续新开的事务是否已提交，并重做这些事务的数据修改；之前的其他日志可以丢弃。


# Undo/Redo日志
同时记录事务中被修改的数据的旧值与新值，规则是：数据修改写回磁盘前，必须先记录日志并flush。

恢复操作：
* 从前往后找已提交的事务，并重做数据修改
* 从后往前找未提交的事务，并撤销数据修改

为防止扫描整个日志，可定时记录`checkpoint`：
* 记录`ctartCheckpoint`（包含所有未提交的事务信息）并flush日志
* 将当前所有脏数据写回磁盘，这里也包括未提交事务的数据修改
* 记录`endCheckpoint`并flush日志
恢复时，从后向前找到一对完整的`startCheckpoint`与`endCheckpoint`即可；可根据`startCheckpoint`时记录的未提交事务以及后续新开的事务进行恢复操作：后续有提交记录的事务修改需重做，后续没有提交记录的事务修改需撤销。