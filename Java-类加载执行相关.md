# Java - 类加载 \ 执行相关

## 类文件结构
* 版本号
* 常量池: 字面量 \ 符号引用
* 访问标记
* 类索引 \ 父类索引 \ 接口索引 (引常量池中的一个符号引用)
* 字段表 (访问标记 \ 名称 (引用常量池) \ 类型的描述符 \ 属性表引用)
* 方法表 (访问标记 \ 名称 (引用常量池) \ 参数与返回值类型的描述符 \ 属性表引用)
* 属性表


## 类加载时机
遇到以下情况时, JVM必须要完成类的初始化:
* 对某个类创建实例 \ 调用静态方法 \ 访问静态成员时
* 对某个类进行反射调用时
* 初始化某个类时, 其父类需要先初始化
* JVM启动时需初始化调用 `main()` 方法的主类
* 解析 `java.lang.invoke.MethodHandle` 方法 (JDK7), 需要调用某个类的静态方法或访问静态成员时, 需要先初始化该类
* 如果接口有默认方法 (JDK8), 某个实现类初始化时需要先初始化该接口类

注意:
* 引用数组类不必触发数组的元素类型的初始化
* final静态成员会放到常量池里, 引用时不会触发类的初始化


## 类加载的各个阶段
* 加载
    * 通过全限定名称找到类的二进制流
    * 将类的二进制流转换为运行时方法区的数据结构
    * 生成一个 `java.lang.Class` 对象
    * 数组类会递归降维加载元素类型
* 验证
    * 文件格式验证
    * 元数据验证 (语义校验)
    * 字节码验证
    * 符号引用验证 (推迟到解析阶段做, 检查能否找到引用的类, 是否有权限访问等)
* 准备: 为类中定义的静态成员分配空间 (只置0, 不初始化; final常量除外)
* 解析: 将类中的符号引用替换成直接引用, 需在执行某些操作符号引用的字节码前完成
    * 类 \ 接口的解析: 需要执行被引用类的加载, 数组类需要递归降维加载元素类型
    * 字段解析: 先找引用类是否有该字段, 没有则顺继承关系从父类 \ 接口类中找
    * 方法解析: 先找引用类, 没有再找父类, 需要确保找到的不是抽象方法
    * 接口方法解析: 先找接口类型, 没有再找父类接口
* 初始化: 调用由JVM生成的 `<cinit>()` 方法
    * 静态成员赋初始值
    * 调用static块
* 使用
* 卸载


## 类加载器
* 三层类加载器:
    * Bootstrap Class Loader: JVM自身实现, 加载 `$JAVA_HOME/lib` 目录下的核心内容 (rt.jar \ tools.jar等), 不能在Java程序中直接引用
    * Extension Class Loader: 加载 `$JAVA_HOME/lib/ext` 目录下的jar包 (非核心但具有通用性的类库)
    * Application Class Loader: 加载 `CLASSPATH` 路径下的类库
* 每个类加载器对应一个独立的类命名空间, 不同类加载器加载同一个类文件, 最终得到多个独立的类
* 父类委托模型: 类加载器收到加载请求时, 先委托给父类去加载, 父类无法加载再尝试自己加载; 自行实现的类加载器无法加载以 `java.lang.` 为前缀的类


## 方法调用
* 静态方法 \ final方法: 编译期即完全确定, 类加载解析阶段即转换为直接引用
* 重载方法的静态指派:
    * 编译期确定, 类加载解析阶段即转换为直接引用
    * 根据参数的静态类型选择一个最合适的版本
* 虚方法的动态指派:
    * 先找到方法接收者的实际类型
    * 检查实际类型是否有实现指定方法, 如果没有就找父类, 找不到抛异常
* 带重载的虚方法:
    * 重载版本静态确定
    * 虚方法运行时确定
* 可以用虚方法表实现, 类似的也有接口方法表; 还有其他优化方法
