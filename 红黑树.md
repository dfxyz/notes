# 红黑树
基本性质：
* 节点非红即黑
* 树根是黑的
* 叶子（null）看作是黑的
* 红节点的两个子节点都是黑的
* 从某个节点往下找，所有路径上的黑节点数量都一致

延伸性质：
* 红节点的两个子节点要么都是黑的实节点，要么都是黑的null
* 黑节点如果有个子节点为null，另一个子节点要么也是null，要么是个红节点


## 旋转
```
    y         x
   / \       / \
  x   c <-> a   y
 / \           / \
a   b         b   c
```

## 插入元素
插入新元素时，先包装在一个红节点里，插入树的末端，再从该节点开始执行插入后的修复流程。

插入一个红节点后，只可能破坏以下两种属性都某一个：
* 红节点下两个子节点都是黑的
* 树根是黑的

修复途中可能遇到以下几种情况：
* 父节点是黑的，这种情况不用修复
* 父节点是红的：
    * 叔节点也是红的，这种情况下可以直接改变祖父、父、叔节点的颜色，再从祖父节点起进行修复
    * 叔节点是黑的，父节点是祖父的左子节点：
        * 当前节点是右孩子，对父节点和该节点进行左旋转，接下来从父节点起进行修复
        * 当前节点是左孩子，对父节点和该节点进行右旋转，旋转后该节点和原父节点改变颜色，即完成修复
    * 叔节点是黑的，父节点是祖父的右子节点，进行对称的调整处理
* 修复到树根时，直接标黑即可

观察到每次选取上层节点继续进行修复时，这些节点都是红节点。

```
    B          R   -> continue from grandparent R
   / \        / \
  R   R ->   B   B
 /          /
R          R

  B`         B`       B"
 / \        / \      / \
R'  B ->   R"  B -> R'  R` -> done
 \        /              \
  R"     R'               B

  B`         B`           B"
 / \        / \          / \
B   R' ->  B   R"  ->   R`  R' -> done
   /            \      /
  R"             R'   B
```

## 删除元素
删除流程：
* 被删节点只有一个或零个子节点：
    * 直接提升子节点（或null节点）
    * 如果被删节点是黑节点，从被删位置起执行修复流程（可能是null）
* 被删节点有左右两个子节点：
    * 寻找右子树中的后继节点（即子树中的最小节点）
    * 后继节点挪到被删节点的位置，颜色改为被删节点的颜色
    * 如果后继节点有右子节点，需要调整到后继节点的原位置
    * 如果后继节点之前是黑色的，从后继节点原先的位置起执行修复流程（可能是null）

红黑树属性破坏分析：
* 如果被删除的节点是红节点
    * 没有子节点，删除后不影响红黑树属性
    * 如果用红节点顶替被删除的红节点，用于顶替的红节点必然是末端节点，顶替后不破坏红黑树属性
    * 如果用黑节点顶替被删除的红节点，顶替后必然破坏各路径下黑节点数量一致的属性；如果它带一个红右子节点，父节点又是个红节点，会破坏红节点必然带两个黑子节点的属性
* 如果被删除的节点是黑节点
    * 没有子节点，除树根外会破坏各路径下黑节点数量一致的属性
    * 如果用红节点替代被删除的黑节点，顶替变色后不会破坏红黑树属性
    * 如果用黑节点替代被删除的黑节点顶替后必然破坏各路径下黑节点数量一致的属性；如果它带一个红右子节点，父节点又是个红节点，会破坏红节点必然带两个黑子节点的属性

修复分析：
* 需要修复的原因：某条路径下少了一个黑节点
* 需要修复的位置：被删节点的原位置，或是用于顶替被删节点的节点原位置
* 最简单的情况：如果需要修复的位置是个红节点，直接变黑即可
```
  B     R | B      R | B -> x 
 /  ->    |  \  ->   |
R         |   R      |

?      ?
 \      \
  ? ->   ?
 /      /
B      x

?      ?
 \      \
  ?      ?
 /  ->  /
B      R
 \
  R
```
修复流程：
* 如果到达根节点了，停止；如果修到某个红节点了，直接变黑即可
* 分情况调整树结构，转移下一次进行修复的位置

以下按待修复的点为左子节点的情况进行分析。

情况1：待修复的2的兄弟3是红的，父节点必然是黑的；由于`1-2`路径上的黑子节点数比`1-3`上少1，3必然带两个非空黑节点4、5。
处理：对1、3进行左旋转，再切换1、3的颜色。
后续：`3-5`路径上黑节点数量不变（同之前的`1-3`），`3-1-4`与`3-5`上黑节点数量一致，但`1-2`仍然比`1-4`少一个黑节点；继续对2进行修复流程。
```
   1(B)              3(B)
   /  \              /  \
2(B)  3(R)    ->   1(R) 5(B)  
      /  \         /  \
    4(B) 5(B)    2(B) 4(B)
```

情况2：待修复的2的兄弟3是黑的，且3带两个黑子节点。
处理：直接把兄弟3改成红色。
后续：`1-2`与`1-3`路径上的黑节点树就一致了；但从子树根1开始，路径上少了一个黑节点；继续从1进行修复流程。
```
  1(?)            1(?)
  /  \            /  \
2(B) 3(B)    -> 2(B) 3(R)
     /  \            /  \
   4(B) 5(B)       4(B) 5(B)
```

情况3：待修复的2的兄弟3是黑的，3带左红右黑两个子节点（根据2是否为null，4可能还有非null黑子节点）。
处理：对`3-4`做右旋处理，并对调3、4的颜色。
后续：`1-3`变换成`1-4`后，路径上的黑节点数量不变；`1-2`依然比`1-4`少一个黑节点；继续从2进行修复流程。
```
  1(?)            1(?)
  /  \            /  \
2(B) 3(B)    -> 2(B) 4(B)
     /  \              \
   4(R) 5(B)           3(R)
                         \
                         5(B)
```

情况4：待修复的2的兄弟3是黑的，3的右子节点5是红的（根据2是否为null，5可能还有非null黑子节点）。
处理：对`1-3`进行左旋转，并对调1、3的颜色，节点5改成黑色。
后续：`1-3-5`变成`3-5`后，路径上黑节点数不变；`1-3-4`变成`3-1-4`后，路径上黑节点数不变；`1-2`变成`3-1-2`后，路径上增加了一个黑节点，完成修复。
```
  1(?)             3(?)
  /  \             /  \
2(B) 3(B)    ->  1(B) 5(B)
     /  \        /  \
   4(?) 5(R)   2(B) 4(?)
```