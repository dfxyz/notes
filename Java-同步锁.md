# Java - 同步锁


## Java对象头
Mark Word + 类型元数据指针 + (可选的数组长度)

### Mark Word
Mark Word中记录了对象的锁定状态 \ GC相关信息 \ HashCode缓存等信息.

结构: `[  bitfields  ][ tag bits ]`.

最低两位的tag bits表示了对象当前的锁状态, 也决定了bitfields的存储结构：
* 未锁定, 不可偏向: [ hash | age | 0 | 01 ]
* 未锁定, 可偏向: [ 0 | epoch | age | 1 | 01 ] 
* 可能锁定, 已偏向: [ threadId | epoch | age | 1 | 01 ] 
* 轻量级锁定: [ 指向栈上锁记录的指针 | 00 ]
* 已膨胀 (升级到重量级锁): [ 指向监视器锁结构的指针 | 10 ]
* GC标记: [ x | 11 ]


## 偏向锁
优化只有某一个特定线程使用同步块或同步方法时的性能. 

状态:
* 可偏向; 还没有被拿过锁
* 已偏向; 被某个线程拿过锁, 但放锁的时候不会修改对象头; 需要进入安全点后才知道拿没拿锁 (JVM内部实现?)

可偏向状态下, 通过CAS操作设置threadId表示锁已经偏向自己.

已偏向状态下, 自己再去拿锁, 检查对象头确认无误后不用再执行其他操作.

已偏向状态下, 其他线程尝试拿锁是通过检查对象头发现锁已偏向其他线程, 需要进入全局安全点后进行后续操作:
* 如果被偏向的线程仍持有锁, 需要把偏向锁升级为轻量级锁; 在锁的所有者线程栈中创建锁记录, 并修改对象头, 最后离开安全点后尝试拿轻量级锁;
* 如果被偏向的线程没有持有锁, 修改对象头恢复可偏向状态 (重偏向), 离开安全点后再次尝试拿锁;

偏向锁持有者放锁时, 会检查对象头是否还是偏向锁模式, 如果是, 无需处理 (其他线程拿锁时才处理); 如果否, 则是轻量级锁模式 (或是已升级成重量级锁), 需要做相应的放锁操作.

对象头中的epoch字段可用来标识对象的偏向状态是否过期, 用于对象重偏向的优化.

可偏向状态下, 对象头不能缓存对象的hash值, 如果逻辑需要计算对象的hash值, 会撤销可偏向状态 (按 <<深入理解JVM>> 的说法是, 偏向锁会升级成重量级锁, 在监视器锁结构内缓存hash值; 疑问: 升级成轻量级锁貌似也没有问题?).


## 轻量级锁
针对大部分锁不存在竞争的假设, 使用CAS操作优化使用同步块或同步方法时的性能. 

状态:
* 未锁定, 不可偏向
* 轻量级锁定

拿锁: 在当前的线程栈中开一个Lock Record, 把Mark Word拷贝过去 (称之为Displace Mark Word), 最后CAS操作把对象头修改为指向Lock Record的指针; 如果CAS成功, 则拿锁成功; 否则拿锁失败, 需要膨胀为重量级锁, 并阻塞当前线程.

放锁: 尝试CAS操作把Displaced Mark Word替换回当前的对象头, 如果成功则放锁完成; 如果失败则表示锁已经膨胀成重量级锁, 需要执行重量级锁的放锁流程.


## 重量级锁
基于OS的Mutex, 包含Entry Set和Wait Set.

状态:
* 未锁定, 不可偏向
* 重量级锁定


## 其他优化措施
* 自旋 / 自适应自旋
* 锁消除 (由JVM进行分析, 消除不必要的加锁)
* 锁粗化 (由JVM进行分析, 连续调用同步方法时把多次加锁改成一次加锁)


## 参考资料
* Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing
