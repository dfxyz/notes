# 堆

用数组表示的二叉树，从下标1开始用比较方便：
* `parent(i) = i / 2`
* `leftChild(i) = 2 * i`
* `rightChild(i) = 2 * i + 1`

最大堆：`value[parent(i)] >= value[i]`，常用于堆排序。
最小堆：`value[parent(i)] <= value[i]`，常用于优先级队列。


## 最大堆排序
### 最大堆化
假设左右子树都已是最大堆，检查当前根节点是否需要跟某个子节点调换。如果发生调换，相关子树可能不再是最大堆，需要以该子节点为树根再执行一次最大堆化。时间复杂度与当前树高相关，`O(lgn)`。

### 构建最大堆
从最后一个非叶子节点n开始，从n到1执行最大堆化操作。时间复杂度`O(n)`。

### 排序
先构建最大堆，不断交换树顶与树中最后一个叶子节点，再缩小树对应的数组范围并最大堆化，每次操作将当前范围中最大的元素放到相对的末尾，即完成了排序。


## 优先级队列
操作：
* 插入元素：插在尾部，并检查是否需要与父节点交换位置（递归）
* 查看最大或最小元素（即最优先的元素）：即数组第一个元素
* 取出最大或最小元素（即最优先的元素）：即数组第一个元素，与最后一个元素交换，再排除该元素后进行堆化操作
* 提升或降低某个元素的优先级：检查是否需要与父节点交换位置（递归）